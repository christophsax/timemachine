% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/timemachine.R
\name{timemachine}
\alias{timemachine}
\title{Travel Through Time}
\usage{
timemachine(..., dates, history)
}
\arguments{
\item{...}{expressions to be evaluated. Expressions can be named, so the name
will appear in the output}

\item{dates}{Date or character. At which points in time should the
expressions be evaluated?}

\item{history}{a data frame with the publication history of the data.
Must have column names `pub_date`, `ref_date` and `value`, plus a column
that idenfies multiple series. Use `check_history()` to check the validity
of a history data.frame}
}
\description{
Core function of the package. Runs through a series of dates and evaluates
one or several expressions with the data available.
}
\examples{
library(tsbox)
library(timemachine)
library(dplyr)
library(tidyr)

# Pseudo History example ----------------------------------------------------

# Constructing pseudo history data. It is assumed that mdeath is available
# one month after the end of the period, but fdeath immediately.
history <-
  bind_rows(
    pseudo_history(mdeaths, "1 month"),
    pseudo_history(fdeaths),
  )  \%>\%
  check_history()

# Telling the time machine where to evaluate
dates = seq(as.Date("1978-01-01"), to = as.Date("1979-10-01"), by = "month")

# Wormhole without an argument makes the latest data available in the
# globalenv(). This is useful to build the models.

# Since version 0.0.2, 'history' is not set via options anymore, and must be
# provided all the time.

wormhole(history)

# latest() returns the latest data

latest(history)

### Bon Voyage

# evalating some models from the forecast package
library(forecast)

# Put each model in a (named) expression. You can construct
fct_data <- timemachine(
  etf = {
    m <- forecast(mdeaths, h = 3)
    m$mean
  },
  arima = {
    m <- forecast(auto.arima(mdeaths), h = 3)
    m$mean
  },
  arimax = {
    m <-
      forecast(
        auto.arima(mdeaths, xreg = window(fdeaths, end = end(mdeaths))),
        xreg = window(fdeaths, start = tsp(mdeaths)[2] + 1/12),
        h = 1
      )
    m$mean
  },
  randomwalk = {
    h = 3
    e <- tsp(mdeaths)[2]
    f <- tsp(mdeaths)[3]
    ts(mdeaths[length(mdeaths)], start = e + 1/f, end = e + h/f, f = f)
  },
  history = history,
  dates = dates
)


# need to find a clever way to get 'reference data'
bench_data <-
  latest(history) \%>\%
  ts_pick("mdeaths") \%>\%
  select(ref_date = time, ref_value = value)

errors <- fct_data \%>\%
  left_join(bench_data, by = "ref_date") \%>\%
  # add fct horizon
  group_by(pub_date, expr) \%>\%
  mutate(h = seq(n())) \%>\%
  ungroup()  \%>\%
  mutate(error = value - ref_value)

# error stats
errors \%>\%
  group_by(expr, h) \%>\%
  summarize(rmse = sqrt(sum(error^2)), mae = (mean(abs(error))))

# scatter plots, by horizon
library(ggplot2)
errors \%>\%
  ggplot() +
  geom_point(aes(x = value, y = ref_value)) +
  facet_grid(h ~ expr)


# Real time data ------------------------------------------------------------

# Set up history
# assuming EXP is available one period before
swiss_history2 <- swiss_history \%>\%
  filter(id \%in\% c("EXP", "GDP.CH")) \%>\%
  mutate(pub_date = if_else(
    id == "EXP",
    add_to_date(pub_date, "-1 quarter"),
    pub_date
    )) \%>\%
  # pc rates
  group_by(id, pub_date) \%>\%
  mutate(value = log(value) - lag(log(value))) \%>\%
  ungroup() \%>\%
  filter(!is.na(value)) \%>\%
  check_history()

# Simulation
# evalating some models from the forecast package
library(forecast)

# Put each model in a (named) expression. You can construct
fct_data <- timemachine(
  etf = {
    m <- forecast(GDP.CH, h = 3)
    m$mean
  },
  arima = {
    m <- forecast(auto.arima(GDP.CH), h = 3)
    m$mean
  },
  arima_exp = {
    m <- forecast(auto.arima(GDP.CH,
                             xreg = window(EXP, end = end(GDP.CH))),
                  xreg = window(EXP, start = tsp(GDP.CH)[2] + 1/12),
                  h = 1)
    m$mean
  },
  randomwalk = {
    h = 3
    e <- tsp(GDP.CH)[2]
    f <- tsp(GDP.CH)[3]
    ts(GDP.CH[length(GDP.CH)], start = e + 1/f, end = e + h/f, f = f)
  },
  history = swiss_history2,
  dates = seq(as.Date("2014-01-01"), to = as.Date("2015-10-01"), by = "quarter")
)

# Evaluation
# see example_annual_gdp.R for advanced use of benchmark data
bench_data <-
  latest(swiss_history2) \%>\%
  ts_pick("GDP.CH") \%>\%
  select(ref_date = time, ref_value = value)

errors <- fct_data \%>\%
  left_join(bench_data, by = "ref_date") \%>\%

  # add fct horizon
  group_by(pub_date, expr) \%>\%
  mutate(h = seq(n())) \%>\%
  ungroup()  \%>\%
  mutate(error = value - ref_value)

# error stats
errors \%>\%
  group_by(expr, h) \%>\%
  summarize(rmse = sqrt(sum(error^2)), mae = (mean(abs(error))))

# scatter plots, by horizon
library(ggplot2)
errors \%>\%
  ggplot() +
  geom_point(aes(x = ref_value, y = value)) +
  facet_grid(h ~ expr)


# Advanced benchmarking -----------------------------------------------------

bench0 <-
  swiss_history \%>\%
  # filter variable of interest (annual GDP)
  filter(id == "GDP.CH") \%>\%
  group_by(pub_date,
           ref_date = as.Date(paste0(data.table::year(ref_date), "-1-1"))
           ) \%>\%
  # drop incomplete years
  filter(n() == 4) \%>\%
  summarize(value = sum(value)) \%>\%

  # calculate percentage change rate
  # need to sort and group by pub data, to get proper lags
  arrange(ref_date) \%>\%
  group_by(pub_date) \%>\%
  mutate(value = value / lag(value) - 1) \%>\%
  ungroup() \%>\%
  filter(!is.na(value))

# 1st BFS value is available in Oct
bench_bfs <-
  bench0 \%>\%
  filter(as.POSIXlt(pub_date)$mon + 1 == 7) \%>\%
  arrange(pub_date) \%>\%
  group_by(ref_date) \%>\%
  slice(1) \%>\%
  ungroup() \%>\%
  select(ref_date, ref_value = value)

# 1st SECO value is the first aailable value
bench_seco <-
  bench0 \%>\%
  arrange(pub_date) \%>\%
  group_by(ref_date) \%>\%
  slice(1) \%>\%
  ungroup() \%>\%
  select(ref_date, ref_value = value)

}
